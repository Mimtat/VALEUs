<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>VALEUS Sankey (Org → Kind of Action → Main Addressee)</title>

  <!-- Plotly -->
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
  <!-- PapaParse for CSV -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    body { margin: 0; font-family: Arial, sans-serif; }
    .page { height: 100vh; overflow-y: auto; overflow-x: hidden; }
    .chartWrap { height: 1200px; padding: 16px; box-sizing: border-box; }
    #chart { width: 100%; height: 100%; }

    /* Minimizable legend panel */
    #legendPanel{
      position: fixed;
      right: 14px;
      top: 14px;
      z-index: 9999;
      width: 300px;
      border-radius: 12px;
      background: rgba(255,255,255,0.95);
      box-shadow: 0 10px 30px rgba(0,0,0,0.12);
      border: 1px solid rgba(0,0,0,0.08);
      overflow: hidden;
      backdrop-filter: blur(6px);
    }
    #legendHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 10px 12px;
      font-size: 13px;
      font-weight: 650;
      color: #111827;
      cursor: pointer;
      user-select: none;
    }
    #legendHeader small{
      font-weight: 500;
      color: #6b7280;
      margin-left: 8px;
    }
    #legendBody{
      padding: 10px 12px 12px 12px;
      border-top: 1px solid rgba(0,0,0,0.06);
      display: block;
      max-height: 70vh;
      overflow: auto;
    }
    .legendRow{
      display:flex;
      align-items:center;
      gap: 10px;
      padding: 6px 0;
      font-size: 12.5px;
      color: #111827;
      border-bottom: 1px dashed rgba(0,0,0,0.06);
    }
    .legendRow:last-child{ border-bottom: none; }
    .swatch{
      width: 14px;
      height: 14px;
      border-radius: 4px;
      border: 1px solid rgba(0,0,0,0.12);
      flex: 0 0 auto;
    }
    .muted{
      color:#6b7280;
      font-size: 12px;
      margin-top: 10px;
      line-height: 1.25;
    }
    .chev{
      font-size: 12px;
      color:#6b7280;
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid rgba(0,0,0,0.08);
      background: rgba(249,250,251,0.7);
    }

    .sectionTitle{
      font-size: 12px;
      font-weight: 700;
      color:#111827;
      margin: 8px 0 6px 0;
    }

    .filterRow{
      display:flex;
      align-items:center;
      gap:10px;
      padding: 6px 0;
      font-size: 12.5px;
      color:#111827;
      border-bottom: 1px dashed rgba(0,0,0,0.06);
    }

    .filterRow input{ transform: translateY(1px); }

    .btnRow{
      display:flex;
      gap:8px;
      margin: 8px 0 10px 0;
    }
    .btn{
      font-size: 12px;
      padding: 6px 8px;
      border-radius: 10px;
      border: 1px solid rgba(0,0,0,0.10);
      background: rgba(249,250,251,0.9);
      cursor: pointer;
    }

    /* Small footer status */
    #status{
      position: fixed;
      left: 14px;
      bottom: 14px;
      z-index: 9999;
      padding: 8px 10px;
      border-radius: 10px;
      background: rgba(255,255,255,0.9);
      border: 1px solid rgba(0,0,0,0.08);
      box-shadow: 0 10px 30px rgba(0,0,0,0.10);
      font-size: 12px;
      color:#374151;
      max-width: 46vw;
    }
    #status code{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 11px; }
  </style>
</head>

<body>
  <div class="page">
    <div class="chartWrap">
      <div id="chart"></div>
    </div>
  </div>

  <div id="legendPanel" aria-label="Legend">
    <div id="legendHeader" title="Click to minimize / expand">
      <div>Action domain filter <small>(and colors)</small></div>
      <div class="chev" id="legendChev">–</div>
    </div>
    <div id="legendBody"></div>
  </div>

  <div id="status"></div>

<script>
/**
 * CONFIG
 * CSV must include these columns (exact names):
 *   1) Name of the Organization
 *   2) Project/Action Domain (select all that apply)
 *   3) Kind of Action (Select all that apply)
 *   4) Main Addressee (Select all that apply)
 */
const CSV_PATH = "./VALEUS_Submissions_normalized_for_sankey.csv";


/** Project identity palette for action domains. */
const CAT_COLORS = {
  "Democracy": "#2F6BFF",
  "Human/Fundamental rights": "#7A3FF2",
  "International/intercultural Understanding": "#7CCF19",
  "Energy/Climate/Sustainability": "#22B8A9",
  "Trade/Economy": "#FFB020",
  "Migration": "#FF5A7A",
  "Conflict/War": "#E43D30",
  "Digital Technology": "#FEDD00",
  "Digital Media": "#00A3FF",
  "European Integration": "#1F3A93",
  "other": "#000000"
};

// UI colors
const KIND_GRAY = "rgba(120,120,120,0.95)";
const LINK_ALPHA = 0.35;

// Column names in your normalized CSV:
const COL_ORG  = "Name of the Organization";
const COL_DOM  = "Project/Action Domain (select all that apply)";
const COL_KIND = "Kind of Action (Select all that apply)";
const COL_ADDR = "Main Addressee (Select all that apply)";

function normalizeToken(s){
  if (s == null) return "";
  return String(s).trim().replace(/\s+/g, " ");
}
function splitMulti(value){
  const v = normalizeToken(value);
  if (!v) return [];
  return v.split(",").map(x => normalizeToken(x)).filter(Boolean);
}
function hexToRgb(hex){
  const h = hex.replace("#", "").trim();
  const full = (h.length === 3) ? h.split("").map(c => c+c).join("") : h;
  const int = parseInt(full, 16);
  return { r:(int>>16)&255, g:(int>>8)&255, b:int&255 };
}
function lightenHex(hex, amount=0.45){
  const {r,g,b} = hexToRgb(hex);
  const nr = Math.round(r + (255 - r) * amount);
  const ng = Math.round(g + (255 - g) * amount);
  const nb = Math.round(b + (255 - b) * amount);
  return `rgb(${nr},${ng},${nb})`;
}
function rgbaFromHex(hex, a=0.35){
  const {r,g,b} = hexToRgb(hex);
  return `rgba(${r},${g},${b},${a})`;
}

function setStatus(msg){
  document.getElementById("status").innerHTML = msg;
}

/**
 * Org color = action-domain of the *first submission row* for that org (file order).
 * This stays stable even when filters change.
 */
function buildOrgColorMap(allRows){
  const orgColor = new Map();
  const orgDomain = new Map();

  for (const row of allRows){
    const org = normalizeToken(row[COL_ORG]);
    if (!org || orgColor.has(org)) continue;

    const domains = splitMulti(row[COL_DOM]);
    const d0 = domains.length ? domains[0] : "other";
    const col = CAT_COLORS[d0] || CAT_COLORS["other"];

    orgColor.set(org, col);
    orgDomain.set(org, d0);
  }
  return { orgColor, orgDomain };
}

/**
 * Addressee color = lighter shade of the org with max incoming flow.
 */
function buildAddresseeColorMap(flowOrgToAddr, orgColor){
  const addrColor = new Map();

  for (const [addr, orgMap] of flowOrgToAddr.entries()){
    let bestOrg = null;
    let bestVal = -Infinity;
    for (const [org, val] of orgMap.entries()){
      if (val > bestVal){
        bestVal = val;
        bestOrg = org;
      }
    }
    const base = orgColor.get(bestOrg) || CAT_COLORS["other"];
    addrColor.set(addr, lightenHex(base, 0.45));
  }
  return { addrColor };
}

/** ------- Legend (minimizable + checkboxes) ------- */
let selectedDomains = new Set(Object.keys(CAT_COLORS).filter(k => k !== "other"));

function initLegend(onFilterChange){
  const header = document.getElementById("legendHeader");
  const body = document.getElementById("legendBody");
  const chev = document.getElementById("legendChev");
  let open = true;

  header.onclick = () => {
    open = !open;
    body.style.display = open ? "block" : "none";
    chev.textContent = open ? "–" : "+";
  };

  const domainKeys = Object.keys(CAT_COLORS).filter(k => k !== "other");

  body.innerHTML = `
    <div class="sectionTitle">Filter Action Domains</div>
    <div class="btnRow">
      <button class="btn" id="btnAll">Select all</button>
      <button class="btn" id="btnNone">Select none</button>
    </div>
    <div id="domainChecks"></div>

    <div class="muted">
  Click to filter action domains.<br/>
  Colors correspond to the organization's base colors.
  `;

  const checksEl = document.getElementById("domainChecks");
  checksEl.innerHTML = domainKeys.map(k => `
   <label class="filterRow">
  <input type="checkbox" data-domain="${k}" checked />
  <span class="swatch" style="background:${CAT_COLORS[k]}"></span>
  <span>${k}</span>
</label>

  `).join("");

 
  document.getElementById("btnAll").onclick = () => {
    selectedDomains = new Set(domainKeys);
    checksEl.querySelectorAll("input[type=checkbox]").forEach(cb => cb.checked = true);
    onFilterChange();
  };
  document.getElementById("btnNone").onclick = () => {
    selectedDomains = new Set();
    checksEl.querySelectorAll("input[type=checkbox]").forEach(cb => cb.checked = false);
    onFilterChange();
  };

  checksEl.addEventListener("change", (e) => {
    const cb = e.target;
    if (!cb || cb.type !== "checkbox") return;
    const d = cb.getAttribute("data-domain");
    if (!d) return;
    if (cb.checked) selectedDomains.add(d);
    else selectedDomains.delete(d);
    onFilterChange();
  });
}

/** Filter rule: keep row if its domains intersect selectedDomains. */
function rowPassesDomainFilter(row){
  const domains = splitMulti(row[COL_DOM]);
  if (!domains.length) return selectedDomains.size === 0 ? false : selectedDomains.has("other");
  for (const d of domains){
    if (selectedDomains.has(d)) return true;
  }
  return false;
}

/** Render Sankey from a (possibly filtered) row set, using stable orgColor computed from full CSV. */
function renderSankey(rows, orgColor){
  // Flows
  const flowOrgKind = new Map();   // org||kind => count
  const flowKindAddr = new Map();  // kind||addr => count
  const flowOrgToAddr = new Map(); // addr => Map(org => total)

  const orgs = new Set();
  const kinds = new Set();
  const addrs = new Set();

  for (const row of rows){
    const org = normalizeToken(row[COL_ORG]);
    if (!org) continue;

    const kindTokens = splitMulti(row[COL_KIND]);
    const addrTokens = splitMulti(row[COL_ADDR]);
    if (!kindTokens.length || !addrTokens.length) continue;

    orgs.add(org);
    kindTokens.forEach(k => kinds.add(k));
    addrTokens.forEach(a => addrs.add(a));

    for (const k of kindTokens){
      const key = `${org}||${k}`;
      flowOrgKind.set(key, (flowOrgKind.get(key) || 0) + 1);
    }
    for (const k of kindTokens){
      for (const a of addrTokens){
        const key = `${k}||${a}`;
        flowKindAddr.set(key, (flowKindAddr.get(key) || 0) + 1);

        if (!flowOrgToAddr.has(a)) flowOrgToAddr.set(a, new Map());
        const m = flowOrgToAddr.get(a);
        m.set(org, (m.get(org) || 0) + 1);
      }
    }
  }

  const { addrColor } = buildAddresseeColorMap(flowOrgToAddr, orgColor);

  const orgList  = Array.from(orgs).sort((a,b) => a.localeCompare(b));
  const kindList = Array.from(kinds).sort((a,b) => a.localeCompare(b));
  const addrList = Array.from(addrs).sort((a,b) => a.localeCompare(b));

  const labels = [...orgList, ...kindList, ...addrList];

  const nodeColor = [];
  for (const o of orgList) nodeColor.push(orgColor.get(o) || CAT_COLORS["other"]);
  for (const k of kindList) nodeColor.push(KIND_GRAY);
  for (const a of addrList) nodeColor.push(addrColor.get(a) || lightenHex(CAT_COLORS["other"], 0.55));

  const orgIdx  = new Map(orgList.map((o,i)=>[o,i]));
  const kindIdx = new Map(kindList.map((k,i)=>[k, orgList.length + i]));
  const addrIdx = new Map(addrList.map((a,i)=>[a, orgList.length + kindList.length + i]));

  const source = [];
  const target = [];
  const value  = [];
  const linkColor = [];

  // Org -> Kind links
  for (const [key, v] of flowOrgKind.entries()){
    const [o,k] = key.split("||");
    if (!orgIdx.has(o) || !kindIdx.has(k)) continue;
    source.push(orgIdx.get(o));
    target.push(kindIdx.get(k));
    value.push(v);
    const base = orgColor.get(o) || CAT_COLORS["other"];
    linkColor.push(rgbaFromHex(base, LINK_ALPHA));
  }

  // Kind -> Addressee links
  for (const [key, v] of flowKindAddr.entries()){
    const [k,a] = key.split("||");
    if (!kindIdx.has(k) || !addrIdx.has(a)) continue;
    source.push(kindIdx.get(k));
    target.push(addrIdx.get(a));
    value.push(v);

    const c = addrColor.get(a) || lightenHex(CAT_COLORS["other"], 0.55);
    const rgba = c.startsWith("rgb(") ? c.replace("rgb(", "rgba(").replace(")", `,${LINK_ALPHA})`) : c;
    linkColor.push(rgba);
  }

  const data = [{
    type: "sankey",
    arrangement: "snap",
    node: {
      pad: 22,
      thickness: 16,
      line: { color: "rgba(0,0,0,0)", width: 0.5 },
      label: labels,
      color: nodeColor
    },
    link: {
      source,
      target,
      value,
      color: linkColor,
      line: { width: 0.3, color: "rgba(0,0,0,0.15)" }
    }
  }];

  const layout = {
    margin: { l: 10, r: 10, t: 10, b: 10 },
    font: { size: 12, color: "#111827" },
    paper_bgcolor: "#ffffff",
    plot_bgcolor: "#ffffff"
  };

  Plotly.newPlot("chart", data, layout, {
    responsive: true,
    scrollZoom: false,
    displayModeBar: true,
    modeBarButtonsToRemove: [
      "zoom2d","pan2d","select2d","lasso2d",
      "zoomIn2d","zoomOut2d","autoScale2d","resetScale2d"
    ]
  });

  return { orgCount: orgList.length, kindCount: kindList.length, addrCount: addrList.length };
}

/** Load once, then re-render on filters. */
let ALL_ROWS = null;
let ORG_COLOR_MAP = null;

async function loadCSVOnce(){
  setStatus(`Loading CSV: <code>${CSV_PATH}</code>`);
  const res = await fetch(CSV_PATH, { cache: "no-store" });
  if (!res.ok){
    setStatus(`Could not fetch CSV (<code>${CSV_PATH}</code>). If you opened this as <code>file://</code>, it will fail. Use GitHub Pages or a local server.`);
    throw new Error("CSV fetch failed");
  }
  const csvText = await res.text();
  const parsed = Papa.parse(csvText, { header: true, skipEmptyLines: true });
  ALL_ROWS = (parsed.data || []).filter(r => Object.keys(r).length);
  if (!ALL_ROWS.length){
    setStatus("CSV parsed, but no rows found.");
    throw new Error("No rows");
  }
  const { orgColor } = buildOrgColorMap(ALL_ROWS);
  ORG_COLOR_MAP = orgColor;
}

function rerender(){
  if (!ALL_ROWS || !ORG_COLOR_MAP) return;

  const filtered = ALL_ROWS.filter(rowPassesDomainFilter);

  console.log("Selected domains:", Array.from(selectedDomains));
  console.log("Filtered rows:", filtered.length);
  console.log("Example filtered domains:", filtered.slice(0, 5).map(r => r[COL_DOM]));

  const stats = renderSankey(filtered, ORG_COLOR_MAP);

  const selected = Array.from(selectedDomains);
  const selTxt = selected.length ? selected.join(", ") : "(none)";
  setStatus(
    `Rendered from <code>${CSV_PATH}</code><br/>` +
    `Filter: <code>${selTxt}</code><br/>` +
    `${stats.orgCount} orgs, ${stats.kindCount} kinds, ${stats.addrCount} addressees.`
  );
}


(async function boot(){
  // legend first so it’s interactive quickly
  initLegend(() => rerender());

  await loadCSVOnce();
  rerender();
})().catch(err => console.error(err));
</script>
</body>
</html>





