<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>VALEUS Sankey (Org → Kind of Action → Main Addressee)</title>

  <!-- Plotly -->
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
  <!-- PapaParse for CSV -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
      body { margin: 0; font-family: Arial, sans-serif; }
  .page { height: 100vh; overflow-y: auto; overflow-x: hidden; }
  .chartWrap { height: 1200px; padding: 16px; box-sizing: border-box; }
  #chart { width: 100%; height: 100%; }

    /* Minimizable legend panel */
    #legendPanel{
      position: fixed;
      right: 14px;
      top: 14px;
      z-index: 9999;
      width: 260px;
      border-radius: 12px;
      background: rgba(255,255,255,0.95);
      box-shadow: 0 10px 30px rgba(0,0,0,0.12);
      border: 1px solid rgba(0,0,0,0.08);
      overflow: hidden;
      backdrop-filter: blur(6px);
    }
    #legendHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 10px 12px;
      font-size: 13px;
      font-weight: 650;
      color: #111827;
      cursor: pointer;
      user-select: none;
    }
    #legendHeader small{
      font-weight: 500;
      color: #6b7280;
      margin-left: 8px;
    }
    #legendBody{
      padding: 10px 12px 12px 12px;
      border-top: 1px solid rgba(0,0,0,0.06);
      display: block;
    }
    .legendRow{
      display:flex;
      align-items:center;
      gap: 10px;
      padding: 6px 0;
      font-size: 12.5px;
      color: #111827;
      border-bottom: 1px dashed rgba(0,0,0,0.06);
    }
    .legendRow:last-child{ border-bottom: none; }
    .swatch{
      width: 14px;
      height: 14px;
      border-radius: 4px;
      border: 1px solid rgba(0,0,0,0.12);
      flex: 0 0 auto;
    }
    .muted{
      color:#6b7280;
      font-size: 12px;
      margin-top: 8px;
      line-height: 1.25;
    }
    .chev{
      font-size: 12px;
      color:#6b7280;
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid rgba(0,0,0,0.08);
      background: rgba(249,250,251,0.7);
    }

    /* Small footer status */
    #status{
      position: fixed;
      left: 14px;
      bottom: 14px;
      z-index: 9999;
      padding: 8px 10px;
      border-radius: 10px;
      background: rgba(255,255,255,0.9);
      border: 1px solid rgba(0,0,0,0.08);
      box-shadow: 0 10px 30px rgba(0,0,0,0.10);
      font-size: 12px;
      color:#374151;
      max-width: 46vw;
    }
    #status code{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 11px; }
  </style>

<div class="page">
  <div class="chartWrap">
    <div id="chart"></div>
  </div>
</div>
  </head>
<body>
  <div id="wrap">
    <div id="chart"></div>
  </div>

  <div id="legendPanel" aria-label="Legend">
    <div id="legendHeader" title="Click to minimize / expand">
      <div>Action domain colors <small>(org color source)</small></div>
      <div class="chev" id="legendChev">–</div>
    </div>
    <div id="legendBody"></div>
  </div>

  <div id="status"></div>

<script>
/**
 * CONFIG
 * - Put your CSV next to this HTML file (same folder) OR change CSV_PATH.
 * - CSV must include these columns (exact names):
 *   1) Name of the Organization
 *   2) Project/Action Domain (select all that apply)
 *   3) Kind of Action (Select all that apply)
 *   4) Main Addressee (Select all that apply)
 */
const CSV_PATH = "VALEUS_Submissions_normalized_for_sankey.csv";

/** Your updated project identity palette for action domains. */
const CAT_COLORS = {
  "Democracy": "#2F6BFF",
  "Human/Fundamental rights": "#7A3FF2",
  "International/intercultural Understanding": "#7CCF19",
  "Energy/Climate/Sustainability": "#22B8A9",
  "Trade/Economy": "#FFB020",
  "Migration": "#FF5A7A",
  "Conflict/War": "#E43D30",
  "Digital Technology": "#FEDD00",
  "Digital Media": "#00A3FF",
  "European Integration": "#1F3A93",
  "other": "#000000"
};

// UI colors
const KIND_GRAY = "rgba(120,120,120,0.95)";      // kind of action nodes
const LINK_ALPHA = 0.35;

// Column names in your normalized CSV:
const COL_ORG  = "Name of the Organization";
const COL_DOM  = "Project/Action Domain (select all that apply)";
const COL_KIND = "Kind of Action (Select all that apply)";
const COL_ADDR = "Main Addressee (Select all that apply)";

function normalizeToken(s){
  if (s == null) return "";
  return String(s).trim().replace(/\s+/g, " ");
}

/** Split comma-separated multi-select fields into tokens, robust to blanks. */
function splitMulti(value){
  const v = normalizeToken(value);
  if (!v) return [];
  return v.split(",").map(x => normalizeToken(x)).filter(Boolean);
}

/** Convert hex to rgb object. */
function hexToRgb(hex){
  const h = hex.replace("#", "").trim();
  const full = (h.length === 3) ? h.split("").map(c => c+c).join("") : h;
  const int = parseInt(full, 16);
  return { r:(int>>16)&255, g:(int>>8)&255, b:int&255 };
}

/** Lighten a hex color toward white. amount in [0,1]. */
function lightenHex(hex, amount=0.45){
  const {r,g,b} = hexToRgb(hex);
  const nr = Math.round(r + (255 - r) * amount);
  const ng = Math.round(g + (255 - g) * amount);
  const nb = Math.round(b + (255 - b) * amount);
  return `rgb(${nr},${ng},${nb})`;
}

/** rgba from hex with alpha */
function rgbaFromHex(hex, a=0.35){
  const {r,g,b} = hexToRgb(hex);
  return `rgba(${r},${g},${b},${a})`;
}

/**
 * Assign an organization color:
 * "take the first entry of the project action of every organization"
 * We interpret this as:
 *  - Find the first row (file order) for that organization.
 *  - Take the first action-domain token from COL_DOM in that row.
 *  - Map via CAT_COLORS (fallback 'other').
 */
function buildOrgColorMap(rows){
  const orgColor = new Map();
  const orgDomain = new Map();

  for (const row of rows){
    const org = normalizeToken(row[COL_ORG]);
    if (!org || orgColor.has(org)) continue;

    const domains = splitMulti(row[COL_DOM]);
    const d0 = domains.length ? domains[0] : "other";
    const col = CAT_COLORS[d0] || CAT_COLORS["other"];

    orgColor.set(org, col);
    orgDomain.set(org, d0);
  }
  return { orgColor, orgDomain };
}

/**
 * Determine addressee colors:
 * "main addressee shall show a lighter shade of the biggest flow of the organization that it receives"
 * We implement:
 *  - Compute total flow into each addressee aggregated by organization (via Kind).
 *  - For each addressee, find the org with max total.
 *  - Addressee node color = lightened( orgColor[maxOrg] )
 */
function buildAddresseeColorMap(flowOrgToAddr, orgColor){
  const addrToBestOrg = new Map();
  const addrColor = new Map();

  for (const [addr, orgMap] of flowOrgToAddr.entries()){
    let bestOrg = null;
    let bestVal = -Infinity;
    for (const [org, val] of orgMap.entries()){
      if (val > bestVal){
        bestVal = val;
        bestOrg = org;
      }
    }
    const base = orgColor.get(bestOrg) || CAT_COLORS["other"];
    addrToBestOrg.set(addr, bestOrg || "other");
    addrColor.set(addr, lightenHex(base, 0.45));
  }
  return { addrToBestOrg, addrColor };
}

function setStatus(msg){
  const el = document.getElementById("status");
  el.innerHTML = msg;
}

// Legend UI (minimizable)
function initLegend(){
  const header = document.getElementById("legendHeader");
  const body = document.getElementById("legendBody");
  const chev = document.getElementById("legendChev");
  let open = true;

  header.addEventListener("click", () => {
    open = !open;
    body.style.display = open ? "block" : "none";
    chev.textContent = open ? "–" : "+";
  });

  // Populate legend
  const entries = Object.entries(CAT_COLORS);
  // Keep 'other' last
  entries.sort((a,b) => (a[0] === "other") - (b[0] === "other"));
  body.innerHTML = entries.map(([k,v]) => `
    <div class="legendRow">
      <span class="swatch" style="background:${v}"></span>
      <span>${k}</span>
    </div>
  `).join("") + `
    <div class="muted">
      Org color = action-domain of the <em>first</em> submission for that org.<br/>
      Kind of Action = gray.<br/>
      Addressee = lighter shade of the org with the largest incoming flow.
    </div>
  `;
}

async function loadAndRender(){
  initLegend();

  setStatus(`Loading CSV: <code>${CSV_PATH}</code>`);
  const res = await fetch(CSV_PATH, { cache: "no-store" });
  if (!res.ok){
    setStatus(`Could not fetch CSV (<code>${CSV_PATH}</code>). Make sure the file is in the same folder as this HTML on GitHub Pages.`);
    throw new Error("CSV fetch failed");
  }
  const csvText = await res.text();

  const parsed = Papa.parse(csvText, { header: true, skipEmptyLines: true });
  const rows = parsed.data || [];
  if (!rows.length){
    setStatus("CSV parsed, but no rows found.");
    return;
  }

  // Build org -> base color using first occurrence in file order
  const { orgColor, orgDomain } = buildOrgColorMap(rows);

  // Build flows:
  //  1) Org -> Kind
  //  2) Kind -> Addressee
  //
  // Also track Org -> Addressee totals (for addressee color assignment)
  const flowOrgKind = new Map(); // key: org||kind => count
  const flowKindAddr = new Map(); // key: kind||addr => count
  const flowOrgToAddr = new Map(); // addr => Map(org => total)

  const orgs = new Set();
  const kinds = new Set();
  const addrs = new Set();

  for (const row of rows){
    const org = normalizeToken(row[COL_ORG]);
    if (!org) continue;

    const kindTokens = splitMulti(row[COL_KIND]);
    const addrTokens = splitMulti(row[COL_ADDR]);

    if (!kindTokens.length || !addrTokens.length) continue;

    orgs.add(org);
    kindTokens.forEach(k => kinds.add(k));
    addrTokens.forEach(a => addrs.add(a));

    // Org -> Kind (count each selection)
    for (const k of kindTokens){
      const key = `${org}||${k}`;
      flowOrgKind.set(key, (flowOrgKind.get(key) || 0) + 1);
    }

    // Kind -> Addressee (count each selection)
    for (const k of kindTokens){
      for (const a of addrTokens){
        const key = `${k}||${a}`;
        flowKindAddr.set(key, (flowKindAddr.get(key) || 0) + 1);

        // Org -> Addressee totals (used for addressee color assignment)
        if (!flowOrgToAddr.has(a)) flowOrgToAddr.set(a, new Map());
        const m = flowOrgToAddr.get(a);
        m.set(org, (m.get(org) || 0) + 1);
      }
    }
  }

  // Addressee colors (lighter shade of best org)
  const { addrColor } = buildAddresseeColorMap(flowOrgToAddr, orgColor);

  // Build node list in order: Org, Kind, Addressee
  const orgList = Array.from(orgs).sort((a,b) => a.localeCompare(b));
  const kindList = Array.from(kinds).sort((a,b) => a.localeCompare(b));
  const addrList = Array.from(addrs).sort((a,b) => a.localeCompare(b));

  const labels = [...orgList, ...kindList, ...addrList];

  const nodeColor = [];
  // Org node colors
  for (const o of orgList){
    nodeColor.push(orgColor.get(o) || CAT_COLORS["other"]);
  }
  // Kind node colors (gray)
  for (const k of kindList){
    nodeColor.push(KIND_GRAY);
  }
  // Addressee node colors (lightened best-org)
  for (const a of addrList){
    nodeColor.push(addrColor.get(a) || lightenHex(CAT_COLORS["other"], 0.55));
  }

  // Index helpers
  const orgIdx = new Map(orgList.map((o,i)=>[o,i]));
  const kindIdx = new Map(kindList.map((k,i)=>[k, orgList.length + i]));
  const addrIdx = new Map(addrList.map((a,i)=>[a, orgList.length + kindList.length + i]));

  // Links
  const source = [];
  const target = [];
  const value  = [];
  const linkColor = [];

  // Org -> Kind links (colored by org base)
  for (const [key, v] of flowOrgKind.entries()){
    const [o,k] = key.split("||");
    if (!orgIdx.has(o) || !kindIdx.has(k)) continue;
    source.push(orgIdx.get(o));
    target.push(kindIdx.get(k));
    value.push(v);

    const base = orgColor.get(o) || CAT_COLORS["other"];
    linkColor.push(rgbaFromHex(base, LINK_ALPHA));
  }

  // Kind -> Addressee links (colored by addressee's underlying base org shade)
  // We'll color by the *destination addressee* node color but slightly higher alpha for clarity.
  for (const [key, v] of flowKindAddr.entries()){
    const [k,a] = key.split("||");
    if (!kindIdx.has(k) || !addrIdx.has(a)) continue;
    source.push(kindIdx.get(k));
    target.push(addrIdx.get(a));
    value.push(v);

    // use addressee color, convert rgb(...) to rgba with alpha
    const c = addrColor.get(a) || lightenHex(CAT_COLORS["other"], 0.55);
    // If already rgb(), wrap into rgba
    const rgba = c.startsWith("rgb(") ? c.replace("rgb(", "rgba(").replace(")", `,${LINK_ALPHA})`) : c;
    linkColor.push(rgba);
  }

  const data = [{
    type: "sankey",
    arrangement: "snap",
    node: {
      pad: 22,
      thickness: 16,
      line: { color: "rgba(0,0,0,0)", width: 0.5 },
      label: labels,
      color: nodeColor
    },
    link: {
      source,
      target,
      value,
      color: linkColor,
      line: { width: 0.3, color: "rgba(0,0,0,0.15)" }
    }
  }];

  const layout = {
    margin: { l: 10, r: 10, t: 10, b: 10 },
    font: { size: 12, color: "#111827" },
    paper_bgcolor: "#ffffff",
    plot_bgcolor: "#ffffff"
  };

 Plotly.newPlot("chart", data, layout, {
  responsive: true,
  scrollZoom: false, // prevents trackpad/wheel zoom from messing up layout
  displayModeBar: true,
  modeBarButtonsToRemove: [
    "zoom2d","pan2d","select2d","lasso2d",
    "zoomIn2d","zoomOut2d","autoScale2d","resetScale2d"
  ]
});


  setStatus(
    `Rendered from <code>${CSV_PATH}</code> — ` +
    `${orgList.length} orgs, ${kindList.length} kinds, ${addrList.length} addressees.`
  );
}

loadAndRender().catch(err => {
  console.error(err);
});
</script>
</body>
</html>

